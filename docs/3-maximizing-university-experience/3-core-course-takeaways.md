# 3.3. Core Course Takeaways

While you are a student, it is difficult to see the big picture of how all the courses you take fit together.

Additionally, not everthing in university is mission critical to your goal of becoming a software engineer.

Knowing what to focus on in each course will help you get the most out of your time in university.

Here are some of the core courses you will likely take in a computer science program, and what you should focus on in each one.

## Data Structures and Algorithms Analysis Course

This course is NOT about memorizing algorithms, data structures, and their runtimes. It's about learning the common patterns so that you are capable of designing your own algorithms and data structures to solve problems.

Many students will tell you this course is important "because it teaches you how to code for job interviews." and it is true that many companies will ask you to solve algorithmic problems "LeetCode style questions" in interviews.

However the real value is in being able to design your own algorithms. You will inevitably have to build some kind of performance critical system in your career, and this course will help give you the foundations for that.

## Operating Systems Course

This course usually focusses on the fundamentals of how operating systems work, including process management, memory management, file systems, and concurrency.

Do you need to be a linux kernel developer to be a good software engineer? No.

However, there are a lot of concepts related to operating systems that are very relevant to building software.

A key part of a software engineer's job is to "operate systems" such as large distributed systems, databases, and cloud platforms.

Concepts like resiliency, fault tolerance, and concurrency are all critical to building robust software systems, and these concepts are often covered in operating systems courses.

Additionally, containers and container orchestration (e.g. Kubernetes) technology critical to building horizontal scaling systems are built on top of operating system concepts, so having a solid understanding of operating systems will help you understand how these technologies work.

## Database Course

Every software engineer will work with databases at some point in their career, so this course is essential.

Do you need to memorize all the fancy proofs for relational algebra and normalization? No.

But you should understand the basics of how databases work, including SQL, database design and concepts like ACID transactions, indexing, and query optimization.

I also find that university database courses focus mostly on relational databases, but in the real world, you will need to understand many different database paradigms.

Without the context of understanding these different database paradigms, you might be confused at why a course like this is spending an entire lecture to discuss what a B+ tree is. The reason why is not every database uses a B+ tree, and understanding the different data structures used in databases will help you understand how to choose the right database for your application.

For example, Cassandra uses a log-structured merge tree (LSM tree) for its storage engine, which makes it better for write-heavy workloads, while MongoDB uses a B-tree for its storage engine, which makes it better for read-heavy workloads.

## Computer Networks Course

This course explores how data moves across the internet and between machines, including topics like protocols (TCP/IP, HTTP), routing, and sockets.

Almost every modern software product relies on networks. Understanding how latency, packet loss, and protocol behavior affect your application will make you a better engineer — especially if you're building APIs, distributed systems, or any service that runs in the cloud.

## Software Engineering Course

It's probably obvious why this one would matter to you as a software engineer.

## Programming Languages & Paradigms Course

This course dives into how different types of programming languages work — functional, imperative, object-oriented, and logic-based languages.

Learning different paradigms helps you think more flexibly about problems.

Different tools solve different problems, and the same is true for the programming language you choose.

Understanding the strengths and weaknesses of different languages will help you choose the right tool for the job, and it will also help you understand how to write better code in the languages you use every day.

## Computer Architecture Course

This course teaches you how computers actually execute the code you write — covering topics like instruction sets, memory hierarchies (cache, RAM, disk), CPU design, and hardware-level optimizations.

Understanding the hardware helps you write more efficient software. It also helps demystify performance issues, especially in low-level systems programming, embedded devices, or optimization-heavy work (like graphics or games).

Software engineers are expected to monitor systems and optimize performance, and understanding the parts of your computer and how they work together will help you do that.

## Cybersecurity Courses

All engineers are responsible for writing secure code. Knowing common attack vectors and how to avoid them will save you (and your company) from massive headaches.

## Artificial Intelligence Courses

AI is another component of modern software engineering. Understanding the basics of machine learning, neural networks, and AI frameworks will help you integrate AI into your applications.
